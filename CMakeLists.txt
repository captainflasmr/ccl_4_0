CMAKE_MINIMUM_REQUIRED(VERSION 3.30)
PROJECT(ccl)
SET(VERSION 4.0.2)

#============================================================================
# Please note:
#
# This should be considered an experimental build system for the CCL.
#
# Linux:
# When make installing with Linux it generates what you would typically expect
# in the install prefix.  If you want debugging symbols with your library
# you should set CMAKE_BUILD_TYPE to Debug or RelWithDebInfo before building.
#
# Windows:
# After building tlhe Release and Debug configurations in Visual Studio and
# running the INSTALL target for both it will generate the following
# libraries:
#
# ${CMAKE_INSTALL_PREFIX}/lib:
#
# ccl_dll.lib   => DLL release version
# ccl_dllD.lib  => DLL debugged version
# ccl_lib.lib   => Statically linked release version
# ccl_libD.lib	=> Statically linked debugged version
#
# ${CMAKE_INSTALL_PREFIX}/bin will include the DLLs you need at runtime if
# you're linking against the shared build of the library.
#
#============================================================================

set(CMAKE_EXPORT_COMPILE_COMMANDS ON CACHE INTERNAL "")

SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 1)
SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR})
IF(MSVC OR MINGW)
    SET(CMAKE_DEBUG_POSTFIX "D")
ENDIF()

SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin
    CACHE PATH "The location where binaries go" FORCE)
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib
    CACHE PATH "The location where libraries go" FORCE)
# Starting with CMake 2.6.0 this will effectively have any DLL files
# generated by CMake be placed in the specified directory.
SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${EXECUTABLE_OUTPUT_PATH})
SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIBRARY_OUTPUT_PATH})
SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIBRARY_OUTPUT_PATH})

IF(CMAKE_COMPILER_IS_GNUCXX)
    CONFIGURE_FILE(cigicl.pc.in_cmake cigicl.pc)
ENDIF()

#==========================================================
# Tests
#==========================================================

INCLUDE(TestBigEndian)
TEST_BIG_ENDIAN(BIG_ENDIAN)

#==========================================================
# Global Preprocessor Definitions
#==========================================================

IF(BIG_ENDIAN)
    ADD_DEFINITIONS(-DCIGI_BIG_ENDIAN)
ELSE()
    ADD_DEFINITIONS(-DCIGI_LITTLE_ENDIAN)
ENDIF()

IF(CMAKE_COMPILER_IS_GNUCXX)
    ADD_DEFINITIONS(-Wall -fmessage-length=0)
ENDIF()

IF(MSVC80)
    ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS)
ENDIF()

#==========================================================
# Define CIGI Class Library Source/Header files.
#==========================================================

file(GLOB_RECURSE CCL_PUBLIC_HDRS "include/*.h")
file(GLOB_RECURSE CCL_HDRS_BASE "include/CigiBase*.h")
file(GLOB_RECURSE CCL_HDRS_V1 "include/*V1*.h")
file(GLOB_RECURSE CCL_HDRS_V2 "include/*V2*.h")
file(GLOB_RECURSE CCL_HDRS_V3 "include/*V3*.h")
file(GLOB_RECURSE CCL_HDRS_V4 "include/*V4*.h")

file(GLOB_RECURSE CCL_SRCS "source/*.cpp")
file(GLOB_RECURSE CCL_SRCS_BASE "source/CigiBase*.cpp")
file(GLOB_RECURSE CCL_SRCS_V1 "source/*V1*.cpp")
file(GLOB_RECURSE CCL_SRCS_V2 "source/*V2*.cpp")
file(GLOB_RECURSE CCL_SRCS_V3 "source/*V3*.cpp")
file(GLOB_RECURSE CCL_SRCS_V4 "source/*V4*.cpp")

#==========================================================
# Library Targets
#==========================================================

INCLUDE_DIRECTORIES(include)

# if ( MSVC )
#   set(SWIG_DIR "C:/Users/jimbo/source/cigi-ccl_4_0/swig/swigwin-4.2.1/swigwin-4.2.1/Lib")
#   set(SWIG_EXECUTABLE "C:/Users/jimbo/source/cigi-ccl_4_0/swig/swigwin-4.2.1/swigwin-4.2.1/swig.exe")
# endif (MSVC)

# find_package(SWIG REQUIRED)
# include(${SWIG_USE_FILE})

# set (CMAKE_SWIG_FLAGS "")

# set_property(SOURCE ccl.i PROPERTY CPLUSPLUS ON)

# set(INTERFACE_FILE_TEMPLATE "${CMAKE_SOURCE_DIR}/ccl.i.in")
# set(INTERFACE_FILE "${CMAKE_SOURCE_DIR}/ccl.i")

# file(GLOB_RECURSE HEADER_FILES "${CMAKE_SOURCE_DIR}/include/*.h")

# # Generate a string with all #include directives for the collected headers
# set(INCLUDE_DIRECTIVES "")
# #foreach(HEADER ${HEADER_FILES})
# #    get_filename_component(DIR_PATH ${HEADER} DIRECTORY)
# #    include_directories(${DIR_PATH})
# #    string(APPEND INCLUDE_DIRECTIVES "#include \"${HEADER}\"\n")
# #endforeach()

# # Configure the .i file with dynamic includes
# # configure_file(${INTERFACE_FILE_TEMPLATE} ${INTERFACE_FILE})

# swig_add_library(cigicl-shared
#   TYPE SHARED
#   LANGUAGE CSharp
#   SOURCES ${CCL_PUBLIC_HDRS} ${CCL_HDRS_BASE} ${CCL_HDRS_V1} ${CCL_HDRS_V2} ${CCL_HDRS_V3} ${CCL_HDRS_V4} ${CCL_SRCS} ${CCL_SRCS_BASE} ${CCL_SRCS_V1} ${CCL_SRCS_V2} ${CCL_SRCS_V3} ${CCL_SRCS_V4} ccl.i
#   OUTPUT_DIR ${CMAKE_SOURCE_DIR}/csharp
#   OUTFILE_DIR ${CMAKE_SOURCE_DIR}
#   )

# #
# # Compiling the CCL as a shared library
# #
if(MSVC OR MINGW)
  add_library(cigicl-shared SHARED
 	 ${CCL_PUBLIC_HDRS}  ${CCL_HDRS_BASE} ${CCL_HDRS_V1} ${CCL_HDRS_V2} ${CCL_HDRS_V3} ${CCL_HDRS_V4}
 	 ${CCL_SRCS} ${CCL_SRCS_BASE} ${CCL_SRCS_V1} ${CCL_SRCS_V2} ${CCL_SRCS_V3} ${CCL_SRCS_V4} ${CMAKE_SOURCE_DIR}/ccl_wrap_patch.cxx)
else()
  add_library(cigicl-shared STATIC
 	 ${CCL_PUBLIC_HDRS}  ${CCL_HDRS_BASE} ${CCL_HDRS_V1} ${CCL_HDRS_V2} ${CCL_HDRS_V3} ${CCL_HDRS_V4}
 	 ${CCL_SRCS} ${CCL_SRCS_BASE} ${CCL_SRCS_V1} ${CCL_SRCS_V2} ${CCL_SRCS_V3} ${CCL_SRCS_V4} ${CMAKE_SOURCE_DIR}/ccl_wrap_patch.cxx)
endif()

source_group("Header Files\\BaseClasses"         FILES ${CCL_HDRS_BASE})
source_group("Header Files\\Version1"            FILES ${CCL_HDRS_V1})
source_group("Header Files\\Version2"            FILES ${CCL_HDRS_V2})
source_group("Header Files\\Version3"            FILES ${CCL_HDRS_V3})
source_group("Header Files\\Version4"            FILES ${CCL_HDRS_V4})
source_group("Source Files\\BaseClasses"         FILES ${CCL_SRCS_BASE})
source_group("Source Files\\Version1"            FILES ${CCL_SRCS_V1})
source_group("Source Files\\Version2"            FILES ${CCL_SRCS_V2})
source_group("Source Files\\Version3"            FILES ${CCL_SRCS_V3})
source_group("Source Files\\Version4"            FILES ${CCL_SRCS_V4})

IF(MSVC OR MINGW)
    # Both the CCL_DLL and _CCL_EXPORTS_ defines are needed to export DLLs.
    SET_TARGET_PROPERTIES(cigicl-shared PROPERTIES
        COMPILE_FLAGS -DCCL_DLL
        DEFINE_SYMBOL _CCL_EXPORTS_
        )
ENDIF()

SET_TARGET_PROPERTIES(cigicl-shared PROPERTIES
    OUTPUT_NAME ccl_dll
    CLEAN_DIRECT_OUTPUT 1
    VERSION ${VERSION}
    SOVERSION 1
)

#
# Compiling the CCL as a static library
#
# IF(MSVC OR MINGW)
#     add_definitions("/MP")
#     ADD_LIBRARY(cigicl-static STATIC ${CCL_PUBLIC_HDRS} ${CCL_SRCS})
#     SET_TARGET_PROPERTIES(cigicl-static PROPERTIES OUTPUT_NAME ccl_lib	)
# ELSE()
#     ADD_LIBRARY(cigicl-static STATIC ${CCL_PUBLIC_HDRS} ${CCL_SRCS})
#     SET_TARGET_PROPERTIES(cigicl-static PROPERTIES OUTPUT_NAME ccl_lib)
# ENDIF()
# SET_TARGET_PROPERTIES(cigicl-static PROPERTIES CLEAN_DIRECT_OUTPUT 1)

#==========================================================
# Install
#==========================================================

# INSTALL(TARGETS cigicl-static cigicl-shared
#         RUNTIME DESTINATION bin
#         LIBRARY DESTINATION lib
#         ARCHIVE DESTINATION lib)
# INSTALL(FILES ${CCL_PUBLIC_HDRS} DESTINATION include/cigicl)
# INSTALL(FILES
#     COPYING
#     ChangeLog
#     license.html
#     README
#     ReleaseNotes.txt
#     DESTINATION share/cigicl)

# IF(CMAKE_COMPILER_IS_GNUCXX)
#     INSTALL(FILES ${CMAKE_BINARY_DIR}/cigicl.pc DESTINATION lib/pkgconfig)
# ENDIF()

add_subdirectory("examples/tinyxml")
add_subdirectory("examples/CigiMiniHost")
add_subdirectory("examples/CigiDummyIG")
if(WIN32)
  add_subdirectory("examples/CigiMiniHostCSharp")
  add_subdirectory("examples/CigiDummyIGCSharp")
endif()
